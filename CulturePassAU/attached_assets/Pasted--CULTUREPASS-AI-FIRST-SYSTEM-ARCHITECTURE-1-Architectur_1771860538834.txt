
ğŸ— CULTUREPASS â€” AI-FIRST SYSTEM ARCHITECTURE

1ï¸âƒ£ Architectural Principles
1. Domain-Driven Structure (DDD)
Each core entity lives in its own module:
/src/modules/
  users/
  locations/
  communities/
  events/
  artists/
  businesses/
  sponsors/
  institutions/
  perks/
  memberships/
  wallet/
  recommendations/

AI can now:
Understand boundaries
Modify isolated logic safely
Avoid breaking the entire app

2. Feature-Based Folder Structure (Not File Chaos)
Instead of:
/pages
/components
/utils

Use:
/modules/events
  event.schema.ts
  event.service.ts
  event.repository.ts
  event.controller.ts
  event.types.ts

AI understands:
What is data
What is logic
What is API
What is database

2ï¸âƒ£ Core Infrastructure Stack (Replit Optimised)
Frontend:
Expo (React Native)
Expo Router
TanStack Query
Zustand
Backend:
Node.js
Express
Drizzle ORM
PostgreSQL
PostGIS
Payments:
Stripe Connect Express
Auth:
Firebase Auth OR Clerk
Hosting (when migrating):
Firebase OR AWS

3ï¸âƒ£ Database Design â€” Culture-Aware Schema
ğŸŒ locations table
countries
states
cities

With:
id
name
type (country/state/city)
parent_id
geo_point (PostGIS)

This creates a tree hierarchy.

ğŸŒ communities table
id
name
type (language / diaspora / indigenous / religion / region)
country_id (nullable)
description
verified

Example community types:
Malayalam Language
Tamil Community
Aboriginal Community
Sikh Community
MÄori Community

ğŸ‘¤ users table (expanded)
primary_country_id
primary_state_id
primary_city_id

origin_country_id
origin_state_id
origin_city_id

radius_preference_km

indigenous_visibility_enabled boolean
homeland_visibility_enabled boolean


ğŸ‘¥ user_communities (join table)
user_id
community_id

Multi-select.

ğŸŸ events table
country_id
state_id
city_id

geo_point (PostGIS)

indigenous_flag boolean

cultural_category
language_tags text[]

visibility_scope (public/community/private)


ğŸŸ event_communities (join table)
event_id
community_id

This enables diaspora + Indigenous filtering.

4ï¸âƒ£ AI-Friendly Recommendation Engine
Create:
/modules/recommendations/
  scoring.service.ts

Scoring formula (example):
score =
  (cityMatch * 50) +
  (stateMatch * 30) +
  (communityMatch * 40) +
  (originMatch * 20) +
  (languageMatch * 25) +
  (followedArtistMatch * 35) +
  (indigenousPriorityBoost * 45)

Then:
ORDER BY score DESC, event_date ASC

AI can adjust weights safely.

5ï¸âƒ£ Discover API Endpoint
GET /api/discover

Server logic:
Fetch user profile
Build weighted SQL query
Apply PostGIS radius filter
Apply community match
Apply Indigenous spotlight logic (if Australia)

6ï¸âƒ£ PostGIS Radius Query (Critical)
Instead of naive filtering:
ST_DWithin(
  event.geo_point,
  user.geo_point,
  radius_in_meters
)

This enables:
â€¢ Sydney 20km
â€¢ NSW state fallback
â€¢ Homeland fallback
Geo intelligence built-in.

7ï¸âƒ£ Indigenous Priority Layer
If user.country = Australia:
Boost events where:
indigenous_flag = true

During:
NAIDOC Week
National Reconciliation Week
Make it time-based.

8ï¸âƒ£ Discover Page Response Structure
Instead of one giant list:
Return structured sections:
{
  "nearYou": [],
  "yourCommunities": [],
  "firstNationsSpotlight": [],
  "fromYourHomeland": [],
  "recommended": []
}

This keeps frontend clean.

9ï¸âƒ£ Permissions + Multi-Tenant Safety
Every query must enforce:
event.status = 'active'
city.status = 'approved'
community.status = 'approved'

Never expose soft-deleted data.

ğŸ”Ÿ AI-Readable Code Practices
To make AI agents powerful in Replit:
âœ… Use explicit types everywhere
âœ… Avoid giant files
âœ… Keep services pure (no side effects)
âœ… Separate DB from logic
âœ… Add JSDoc on services
Example:
/**
 * Returns structured discover sections for a user.
 * Applies geo, community, indigenous and homeland weighting.
 */
export async function getDiscoverFeed(userId: string)

AI understands intent.

1ï¸âƒ£1ï¸âƒ£ Future Scale Layer (CultureOS Vision)
Later you can add:
â€¢ Redis caching for Discover
â€¢ Feature flag system
â€¢ A/B algorithm testing
â€¢ City revenue analytics
â€¢ AI-curated cultural summaries

ğŸ§  Why This Architecture Is Superior
Because:
It is not a CRUD app.
It is:
â€¢ Geo-indexed
â€¢ Community-indexed
â€¢ Identity-aware
â€¢ Indigenous-prioritised
â€¢ Diaspora-connected
â€¢ AI-adjustable
â€¢ Multi-country scalable

ğŸš€ Replit Action Plan (Immediate)
Step 1:
Refactor into /modules/ structure.
Step 2:
Implement locations, communities, user_communities, event_communities.
Step 3:
Enable PostGIS.
Step 4:
Build /discover endpoint returning structured sections.
Step 5:
Add scoring service.


