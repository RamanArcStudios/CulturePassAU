Perfect. Letâ€™s fix this properly at **system level**, not patch level.

Youâ€™re building infrastructure â€” not a toy ticket screen.

Below is the complete fix plan for:

1. âœ… â€œEvent Not Foundâ€ bug
2. âœ… Real QR-based ticket system
3. âœ… Admin / Worker scanner system
4. âœ… Scanned / Attended tracking
5. âœ… Proper payment tracking + organiser dashboard

---

# âœ… 1ï¸âƒ£ Fix: â€œEvent Not Foundâ€ on Ticket Page

### Why this happens

Usually one of these:

â€¢ Ticket stores `eventId` but event is soft-deleted
â€¢ Ticket fetch runs before event query resolves
â€¢ Wrong relation mapping
â€¢ Event status filter excludes it (`published` only)
â€¢ Route param mismatch in Expo Router

---

### ğŸ”¥ Proper Backend Fix (Drizzle/Postgres)

Your `tickets` table MUST reference event properly:

```ts
export const tickets = pgTable("tickets", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  eventId: varchar("event_id").references(() => events.id),
  userId: varchar("user_id").references(() => users.id),
  ticketTypeId: varchar("ticket_type_id"),
  status: varchar("status").default("active"), // active | cancelled | refunded | scanned
  qrCode: text("qr_code"),
  scannedAt: timestamp("scanned_at"),
  scannedBy: varchar("scanned_by"),
  createdAt: timestamp("created_at").defaultNow()
});
```

---

### ğŸ”¥ Correct Fetch Logic (Important)

DO NOT fetch event separately by route param.

Instead:

```ts
const ticket = await db.query.tickets.findFirst({
  where: eq(tickets.id, ticketId),
  with: {
    event: true
  }
});
```

If event is null â†’ fallback UI:

```tsx
if (!ticket?.event) {
  return <EmptyState title="Event not available" />
}
```

NEVER show raw "Event Not Found".

---

# âœ… 2ï¸âƒ£ REAL TICKET SYSTEM (With Secure QR Code)

We do NOT use fake QR strings.

We generate secure signed QR payload.

---

## ğŸ” QR Code Payload Format

Use signed JSON:

```json
{
  "ticketId": "uuid",
  "eventId": "uuid",
  "userId": "uuid",
  "issuedAt": "timestamp"
}
```

Then sign with HMAC (server-side).

Store ONLY ticketId in QR.

Better:

```
culturepass://scan/TICKET_UUID
```

---

## ğŸŸ Generate QR (Backend)

Use:

```bash
npm install qrcode
```

```ts
import QRCode from "qrcode";

const qrData = `culturepass://ticket/${ticket.id}`;

const qrImage = await QRCode.toDataURL(qrData);
```

Store in `tickets.qrCode`.

---

# âœ… 3ï¸âƒ£ Admin & Worker Scanning System

We create a NEW role:

```
event_worker
```

Permissions:
â€¢ Scan tickets
â€¢ View attendees
â€¢ Cannot edit event
â€¢ Cannot see payments

---

## ğŸ¯ New Table

```ts
export const eventStaff = pgTable("event_staff", {
  id: varchar("id").primaryKey(),
  eventId: varchar("event_id"),
  userId: varchar("user_id"),
  role: varchar("role") // admin | worker
});
```

---

# âœ… 4ï¸âƒ£ Ticket Scanning Flow

## ğŸ“± Worker Scanner Screen

Inside app:

New page:

```
/scan/[eventId]
```

Use:

```bash
expo-barcode-scanner
```

---

### Scan Flow

1. Worker scans QR
2. App extracts ticketId
3. Calls API:

```
POST /api/tickets/scan
```

---

### Scan API Logic

```ts
const ticket = await db.query.tickets.findFirst({
  where: eq(tickets.id, scannedTicketId)
});

if (!ticket) return error("Invalid Ticket");

if (ticket.status === "scanned")
  return error("Already scanned");

await db.update(tickets)
  .set({
    status: "scanned",
    scannedAt: new Date(),
    scannedBy: workerId
  })
  .where(eq(tickets.id, ticket.id));
```

---

### Result States

| Status    | Meaning         |
| --------- | --------------- |
| active    | Valid           |
| scanned   | Already entered |
| cancelled | Not valid       |
| refunded  | Not valid       |

---

# âœ… 5ï¸âƒ£ Attendance Tracking

Add to event dashboard:

### Attendee Stats:

â€¢ Total tickets sold
â€¢ Checked in count
â€¢ Remaining
â€¢ Revenue total
â€¢ Refund total

Query:

```sql
SELECT 
  COUNT(*) as sold,
  COUNT(*) FILTER (WHERE status = 'scanned') as attended
FROM tickets
WHERE event_id = $1;
```

---

# âœ… 6ï¸âƒ£ Proper Payment Tracking (Stripe Connect)

You MUST store:

```ts
grossAmount
stripeFee
platformCommission
cityShare
netToOrganizer
```

---

## ğŸ§¾ payments table

```ts
export const payments = pgTable("payments", {
  id: varchar("id").primaryKey(),
  eventId: varchar("event_id"),
  ticketId: varchar("ticket_id"),
  amount: integer("amount"),
  stripeFee: integer("stripe_fee"),
  platformFee: integer("platform_fee"),
  cityShare: integer("city_share"),
  organizerAmount: integer("organizer_amount"),
  status: varchar("status"),
  stripePaymentIntentId: varchar("stripe_payment_intent_id"),
  createdAt: timestamp("created_at").defaultNow()
});
```

---

# âœ… 7ï¸âƒ£ Organizer Dashboard Must Show

Inside:

## ğŸ“Š Revenue Overview

â€¢ Gross Revenue
â€¢ Stripe Fees
â€¢ Platform Commission
â€¢ Net Earnings
â€¢ Payout Status

---

## ğŸ“ˆ Real Example Calculation

If ticket = $100

Stripe 2.9% + 30c = $3.20
Platform 5% = $5
City share 1% = $1

Organizer gets:

$100 - 3.20 - 5 - 1 = $90.80

---

# âœ… 8ï¸âƒ£ Prevent â€œEvent Not Foundâ€ Forever

Add this rule:

Event is never hard-deleted.
Only soft-delete:

```ts
status: draft | published | archived
```

Tickets can reference archived events safely.

---

# âœ… 9ï¸âƒ£ Full System Flow (Correct)

User buys ticket â†’
Stripe PaymentIntent â†’
Webhook confirms payment â†’
Create ticket â†’
Generate QR â†’
Save payment record â†’
Show in My Tickets

Worker scans â†’
Status changes â†’
Dashboard updates live

---

# ğŸš€ Now You Have:

âœ” Real ticket system
âœ” Fraud-resistant QR
âœ” Event staff permissions
âœ” Attendance tracking
âœ” Payment ledger
âœ” Organizer revenue analytics

---

If you want next:

I can now give you:

â€¢ ğŸ”¥ Full Drizzle schema file (complete production ready)
â€¢ ğŸ”¥ Full Expo scanner screen code
â€¢ ğŸ”¥ Full Stripe webhook handler
â€¢ ğŸ”¥ Organizer dashboard UI layout
â€¢ ğŸ”¥ Role-based middleware structure

Tell me which one you want first.
