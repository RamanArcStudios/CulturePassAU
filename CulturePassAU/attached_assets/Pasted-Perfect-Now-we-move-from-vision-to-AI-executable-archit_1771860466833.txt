Perfect. Now we move from **vision** to **AI-executable architecture** for Replit.

You don‚Äôt just need clean code.
You need **machine-understandable system design** so AI agents (Replit AI, Cursor, Copilot, etc.) can reason about it safely.

Below is a **production-ready architecture blueprint** for CulturePass powered by CultureOS ‚Äî optimised for:

‚Ä¢ Replit
‚Ä¢ PostgreSQL + PostGIS
‚Ä¢ Drizzle ORM
‚Ä¢ AI-assisted development
‚Ä¢ Multi-country scale
‚Ä¢ Cultural + geo-aware discovery

---

# üèó CULTUREPASS ‚Äî AI-FIRST SYSTEM ARCHITECTURE

---

# 1Ô∏è‚É£ Architectural Principles

### 1. Domain-Driven Structure (DDD)

Each core entity lives in its own module:

```
/src/modules/
  users/
  locations/
  communities/
  events/
  artists/
  businesses/
  sponsors/
  institutions/
  perks/
  memberships/
  wallet/
  recommendations/
```

AI can now:

* Understand boundaries
* Modify isolated logic safely
* Avoid breaking the entire app

---

### 2. Feature-Based Folder Structure (Not File Chaos)

Instead of:

```
/pages
/components
/utils
```

Use:

```
/modules/events
  event.schema.ts
  event.service.ts
  event.repository.ts
  event.controller.ts
  event.types.ts
```

AI understands:

* What is data
* What is logic
* What is API
* What is database

---

# 2Ô∏è‚É£ Core Infrastructure Stack (Replit Optimised)

Frontend:

* Expo (React Native)
* Expo Router
* TanStack Query
* Zustand

Backend:

* Node.js
* Express
* Drizzle ORM
* PostgreSQL
* PostGIS

Payments:

* Stripe Connect Express

Auth:

* Firebase Auth OR Clerk

Hosting (when migrating):

* Firebase OR AWS

---

# 3Ô∏è‚É£ Database Design ‚Äî Culture-Aware Schema

## üåç locations table

```ts
countries
states
cities
```

With:

```
id
name
type (country/state/city)
parent_id
geo_point (PostGIS)
```

This creates a tree hierarchy.

---

## üåê communities table

```ts
id
name
type (language / diaspora / indigenous / religion / region)
country_id (nullable)
description
verified
```

Example community types:

* Malayalam Language
* Tamil Community
* Aboriginal Community
* Sikh Community
* MƒÅori Community

---

## üë§ users table (expanded)

```ts
primary_country_id
primary_state_id
primary_city_id

origin_country_id
origin_state_id
origin_city_id

radius_preference_km

indigenous_visibility_enabled boolean
homeland_visibility_enabled boolean
```

---

## üë• user_communities (join table)

```ts
user_id
community_id
```

Multi-select.

---

## üéü events table

```ts
country_id
state_id
city_id

geo_point (PostGIS)

indigenous_flag boolean

cultural_category
language_tags text[]

visibility_scope (public/community/private)
```

---

## üéü event_communities (join table)

```ts
event_id
community_id
```

This enables diaspora + Indigenous filtering.

---

# 4Ô∏è‚É£ AI-Friendly Recommendation Engine

Create:

```
/modules/recommendations/
  scoring.service.ts
```

Scoring formula (example):

```ts
score =
  (cityMatch * 50) +
  (stateMatch * 30) +
  (communityMatch * 40) +
  (originMatch * 20) +
  (languageMatch * 25) +
  (followedArtistMatch * 35) +
  (indigenousPriorityBoost * 45)
```

Then:

```
ORDER BY score DESC, event_date ASC
```

AI can adjust weights safely.

---

# 5Ô∏è‚É£ Discover API Endpoint

```
GET /api/discover
```

Server logic:

1. Fetch user profile
2. Build weighted SQL query
3. Apply PostGIS radius filter
4. Apply community match
5. Apply Indigenous spotlight logic (if Australia)

---

# 6Ô∏è‚É£ PostGIS Radius Query (Critical)

Instead of naive filtering:

```sql
ST_DWithin(
  event.geo_point,
  user.geo_point,
  radius_in_meters
)
```

This enables:

‚Ä¢ Sydney 20km
‚Ä¢ NSW state fallback
‚Ä¢ Homeland fallback

Geo intelligence built-in.

---

# 7Ô∏è‚É£ Indigenous Priority Layer

If user.country = Australia:

Boost events where:

```
indigenous_flag = true
```

During:

* NAIDOC Week
* National Reconciliation Week

Make it time-based.

---

# 8Ô∏è‚É£ Discover Page Response Structure

Instead of one giant list:

Return structured sections:

```json
{
  "nearYou": [],
  "yourCommunities": [],
  "firstNationsSpotlight": [],
  "fromYourHomeland": [],
  "recommended": []
}
```

This keeps frontend clean.

---

# 9Ô∏è‚É£ Permissions + Multi-Tenant Safety

Every query must enforce:

```
event.status = 'active'
city.status = 'approved'
community.status = 'approved'
```

Never expose soft-deleted data.

---

# üîü AI-Readable Code Practices

To make AI agents powerful in Replit:

### ‚úÖ Use explicit types everywhere

### ‚úÖ Avoid giant files

### ‚úÖ Keep services pure (no side effects)

### ‚úÖ Separate DB from logic

### ‚úÖ Add JSDoc on services

Example:

```ts
/**
 * Returns structured discover sections for a user.
 * Applies geo, community, indigenous and homeland weighting.
 */
export async function getDiscoverFeed(userId: string)
```

AI understands intent.

---

# 1Ô∏è‚É£1Ô∏è‚É£ Future Scale Layer (CultureOS Vision)

Later you can add:

‚Ä¢ Redis caching for Discover
‚Ä¢ Feature flag system
‚Ä¢ A/B algorithm testing
‚Ä¢ City revenue analytics
‚Ä¢ AI-curated cultural summaries

---

# üß† Why This Architecture Is Superior

Because:

It is not a CRUD app.

It is:

‚Ä¢ Geo-indexed
‚Ä¢ Community-indexed
‚Ä¢ Identity-aware
‚Ä¢ Indigenous-prioritised
‚Ä¢ Diaspora-connected
‚Ä¢ AI-adjustable
‚Ä¢ Multi-country scalable

---

# üöÄ Replit Action Plan (Immediate)

Step 1:
Refactor into `/modules/` structure.

Step 2:
Implement `locations`, `communities`, `user_communities`, `event_communities`.

Step 3:
Enable PostGIS.

Step 4:
Build `/discover` endpoint returning structured sections.

Step 5:
Add scoring service.

---

If you want next, I can:

* Write the full Drizzle schema
* Generate the SQL for PostGIS
* Build the full discover endpoint code
* Create the folder structure template
* Design the AI prompt template for Replit to auto-generate modules

What do we build next?
